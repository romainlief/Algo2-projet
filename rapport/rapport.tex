\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{indentfirst}
\usepackage{appendix}
\usepackage{libertine}
\usepackage{titlesec}
\usepackage{eso-pic}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{caption}
\usepackage{color}
\usepackage{setspace}
\usepackage[T1]{fontenc}
\usepackage[hyphens]{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex}
\addbibresource{source.bib}\usepackage[linkbordercolor=white]{hyperref}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{bm}
\usepackage{enumitem}
\usepackage{siunitx}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{commath}
\usepackage{cancel}
\usepackage{pdflscape}
\usepackage{svg}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e} % Retain only one package
\usepackage{comment}
\usepackage{placeins}

\usepackage{listings}
\lstset{literate=%
    {à}{{\`a}}1 {â}{{\^a}}1 {é}{{\'e}}1 {è}{{\`e}}1 {ê}{{\^e}}1 {ë}{{\"e}}1 {î}{{\^i}}1 {ï}{{\"i}}1 {ô}{{\^o}}1 {ö}{{\"o}}1 {ù}{{\`u}}1 {û}{{\^u}}1 {ü}{{\"u}}1 {ç}{{\c{c}}}1 {Ç}{{\c{C}}}1{―}{{\textemdash}}1
    {’}{{'}}1 {‘}{{`}}1 {“}{{``}}1 {”}{{''}}1
}
\urlstyle{same}
\pagestyle{fancy}
\fancyhead[L]{\leftmark}
\fancyhead[R]{}
\renewcommand{\subsectionmark}[1]{}


\usepackage{titlesec}
\usepackage{hyperref}

\titleclass{\subsubsubsection}{straight}[\subsection]


\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered


\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\setlength{\headheight}{14.5pt}
\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{0.6}
\renewcommand{\headrulewidth}{1pt}
\newcommand{\HRule}{\rule{\linewidth}{0.3mm}}
\newcommand\BackgroundPic{%
	\put(0,0){%
		\parbox[b][\paperheight]{\paperwidth}{%
			\vfill
			\centering
			\includegraphics[width=\paperwidth,height=\paperheight,%
			keepaspectratio]{background.png}%
			\vfill}}}

% -----------------------------------------------------


\begin{document}
\AddToShipoutPicture*{\BackgroundPic}
\begin{titlepage}
  \begin{sffamily}
  \begin{flushleft} \large
    \includegraphics[height=2.0cm]{logo_ulb.jpg}
    \vspace{5cm}
   \end{flushleft}
  \begin{center}

    %Title
	\textsc{\huge INFO-F203 - Projets d'algorithmique 2}\\[1cm]

    \HRule \\[0.7cm]

	\textsc {\Huge Projet Mobilité}\\[0.4cm]

    \HRule \\[1.2cm]

% Author and supervisor
\begin{minipage}{0.5\textwidth}
\begin{flushleft} \large
\emph{Auteurs:}\\
Romain \textsc{Liefferinckx} - 000591790\\
Manuel \textsc{Rocca} - 000596086\\


\end{flushleft}
\end{minipage}


\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Professeurs:} \\
Jean  \textsc{Cardinal}\\
\emph{Assistants:} \\
Robin \textsc{Petit}
\end{flushright}
\end{minipage}


    \vfill

    %Bottom of the page
    {\large Année académique 2024-2025}
  \end{center}

  \end{sffamily}
\end{titlepage}


\clearpage


\tableofcontents

\newpage

% -----------------------------------------------------

\section{Introduction}
Dans le cadre de notre cours d'algorithmique INFO F-203, l'occasion s'est présentée à nous de créer un programme cherchant un chemin optimal
entre un point A et un point B sur base d'une heure de départ. En effet, sur base d'un ensemble de données
fournies sous format \emph{General Transit Feed Specification} (\textbf{GTFS}), nous avons utilisé le \emph{Connexion Scan Algorithm} (\textbf{CSA})
pour implémenter notre chercheur de chemin en \emph{Java}. 

Dans les sections à suivre, nous abordons l'initialisation des données, des structures formées à partir de celles-ci pour notre
implémentation et certains détails techniques comme la complexité temporelle et spatiale. Nous justifierons également certains choix
comme celui de l'algorithme précisé ci-dessus, à savoir le \textbf{CSA}.


\section{Initialisation des données}
Dans cette section nous expliquons les procédés utilisés pour charger les données en mémoire à partir des fichiers CSV fournis ainsi que
les structures de données utilisées pour leur stockage et leur utilisation optimale dans l'algorithme choisi par nos soins.

Tout d'abord, décrivons brièvement la classe Parser, qui se charge de la lecture des fichiers CSV et de la création de dictionnaires (\emph{HashMap}) contenant les données chargées, faciles d'accès.
Nous avons créé, pour chaque type de fichier CSV, une classe de stockage qui contient les attributs correspondants aux champs du fichier CSV. Quelques subtilités notables au sujet de ces classes sont
décrites dans les sections suivantes.

\subsection{Objets de base pour le stockage}
Les fichiers CSV fournis contiennent des informations sur les arrêts, les trajets, les horaires et les routes de quatre entreprises de transport en commun,
à savoir la STIB en région Bruxelloise, TEC en région Wallone, DELIJN en région FLamande et, finalement, la SNCB pour le transport ferroviaire au niveau national.

Pour chaque type de fichier CSV, voici donc les classes correspondantes créées pour contenir les données de manière accessible.

\subsubsection{La classe Route}
Cette classe est une simple classe de stockage, chaque attribut correspondant à un champ des fichiers \emph{routes.csv}.

% Table qui détaille la classe Route
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    route\_id & final String & L'identifiant de la route représentée \\
    route\_short\_name & final String & Le nom de la route raccourci \\
    route\_long\_name & final String & Le nom de la route complet \\
    route\_type & final String & Le type de véhicule utilisant cette route \\
    \hline
    \end{tabular}
    \caption{Classe Route}
\end{table}

\subsubsection{La classe StopTime}
La particularité de cette classe est qu'il lui manque le champ trip\_id donné dans les CSV concernés. Ce choix découle
de la structure de la classe Trip détaillée dans la section \hyperref[sec:trip]{2.1.4}.
% Table qui détaille la classe StopTime
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    departure\_time & final String & L'heure du départ à partir de
                                   l'arrêt associé sur le trajet associé en format 
                                   heure;minutes;secondes \\
    stop\_id & final String & L'identifiant de l'arrêt associé \\
    stop\_sequence & final int & Le numéro de l'arrêt dans le trajet associé \\
    \hline
    \end{tabular}
    \caption{Classe StopTime}
\end{table}

\subsubsection{La classe Stop}
Dans cette classe, hormis le fait que chaque champ des fichiers \emph{routes.csv} est repris, nous avons fait le choix d'ajouter
une liste de trip\_id, permettant de retrouver efficacement chaque trajet partant de cet arrêt ainsi qu'une liste de \hyperref[sec:walk]{\emph{Walk}}, permettant
d'avoir un accès rapide à tous les arrêts accessibles à pied depuis cet arrêt.

Cette classe comprend également une méthode \emph{getDistanceToOther} qui permet de calculer la distance entre deux arrêts en utilisant la formule de Haversine,
implémentée dans une classe annexe, la classe \emph{Calculator}.

% Table qui détaille la classe Stop
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    stop\_id & final String & L'identifiant du stop représenté \\
    stop\_name & final String & Le nom du stop \\
    stop\_lat & final String & La latitude du stop \\
    stop\_lon & final String & La longitude du stop \\
    trip\_ids & List$<$String$>$ & La liste des tous les trips (leurs identifiants) partant de ce stop \\
    walks & List$<$Walk$>$ & La liste de tous les arrêts accessibles à pied depuis ce stop \\
    \hline
    \end{tabular}
    \caption{Classe Stop}
\end{table}

\subsubsection{La classe Trip}
\label{sec:trip}
Une fois de plus, en plus des champs trouvés dans les fichiers \emph{trips.csv} retranscrits en attribut, nous avons ajouté
une liste d'heures d'arrêt associés à ce trajet. Ceci nous permet de construire efficacement les connexions entre arrêts affublées
de temps de départ et d'arrivée.

% Table qui détaille la classe Trip
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    trip\_id & final String & L'identifiant du trip représenté \\
    route\_id & final String & L'identifiant de la route sur laquelle il passe \\
    stop\_times & List$<$StopTime$>$ &  La liste de tous les StopTime associés à ce trip \\
    \hline
    \end{tabular}
    \caption{Classe Trip}
\end{table}

\subsection{Création des structures de données}
Une fois les données lues et contenues dans des dictionnaires faciles d'accès (accès en temps constant), nous procédons à la création de structures de données
pertinentes à notre algorithme de recherche de chemin, le CSA à l'aide de la classe Builder.

La classe Builder est responsable de la création d'une liste de connexions entre arrêts, de la création du BallTree utilisé pour construire efficacement les transferts à pied entre arrêts
et, finalement, la création de ces transferts à pied.

\subsubsection{La classe Connexion}
L'algorithme CSA se base, comme son nom l'indique, sur des connexions entre les différents arrêts. Pour traiter cet aspect, nous avons fait le choix logique
d'implémenter une classe \emph{Connexion}.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    trip\_id & final String & L'identifiant du trajet utilisé par la connexion \\
    from\_id & final String & L'identifiant de l'arrêt de de départ \\
    to\_id & final String &  L'identifiant de l'arrêt d'arrivée \\
    departure\_time & final int & L'heure de départ de l'arrêt \emph{from\_id} \\
    arrival\_time & final int & L'heure d'arrivée à l'arrêt \emph{to\_id} \\
    \hline
    \end{tabular}
    \caption{Classe Trip}
\end{table}


\subsubsection{La class BallTree}
Afin de construire les transferts à pied (limités à une distance arbitraire), nous avons d'abord commencé par une implémentation brute-force en itérant, pour chaque arrêt, sur tous les
autres arrêts en $O(n^2)$, $n$ étant le nombre d'arrêts. Cependant, avec un total d'environ 65\,000 arrêts, cette approche impliquait environ 4\,5 milliards d'itérations avec, à chaque 
itération, une série d'opérations comme par exemple le calcul de la distance entre deux arrêts, en temps constant. Ceci nous a mené à un temps d'exécution d'environ 10 minutes sur nos 
machines rien que pour la création de ces transferts à pied, ce qui est, vous en conviendrez, absolument inacceptable.

Afin de remédier à ce problème critique, nous nous sommes penchés sur des structures de données plus adaptées à ce type de problème. Suite à une série de recherches, nous avons 
considéré des options comme le \emph{R-Tree}, la \emph{Spatial Grid} (≃\emph{Hash Grid}) ou encore le \emph{BallTree}. Nous avons finalement opté pour ce dernier % TODO: justifier efficacement en comparant aux particularités des autres structures


\subsubsection{La classe Walk}
\label{sec:walk}
Classe simple, représentant un transfert à pied entre deux arrêts. Ces objets sont contenus sous forme de liste dans les arrêts correspondants.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    departure & final Stop & L'arrêt de départ du transfert à pied \\
    destination & final Stop & L'arrêt d'arrivée du transfert à pied \\
    duration & final int & La durée en secondes du transfert à pied \\
    \hline
    \end{tabular}
    \caption{Classe Walk}
\end{table}


\subsection{Complexité de l'initialisation}
Bien qu'étant une étape antérieure à l'exécution de l'algorithme, il reste important de discuter la complexité de cette étape. En effet, si nous avions choisi d'absolument ignorer
l'aspect de la complexité, nous aurions pu rester sur une implémentation brute-force, prenant 10 minutes à l'exécution. Bien entendu, pour éviter ces absurdités, nous avons apporté
un soin particulier à la création de ces structures de données.

\subsubsection{Complexité temporelle}
L'initialisation des données se fait en plusieurs étapes, chacune ayant sa propre complexité. Premièrement, nous avons la lecture des fichiers CSV, qui a naturellement une complexité
linéaire $O(n)$, où $n$ est le nombre de lignes dans le fichier. Ensuite, pour la création des connexions, nous itérons dans tous les trajets et, pour chaque trajet, nous itérons dans leurs heures
d'arrêts associés. Notons $n$ le nombre de trajets et $m$ le nombre d'arrêts associés à chaque trajet. La complexité de cette étape est donc $O(n \cdot m)$. Une fois la liste de connexions créée, nous
procédons au tri de celle-ci en se basant sur l'heure de départ de chaque connexion à l'aide de l'algorithme de tri \emph{TimSort}, utilisé par \emph{Collections.sort()}. Ceci se fait dans les pires et
moyen cas avec une complexité de $O(n \log n)$, où $n$ est le nombre de connexions avec un meilleur cas s'exécutant en $O(n)$ (si la liste est déjà majoritairement triée).
% construction BallTree
% n * recherche dans l'arbre

\subsubsection{Complexité spatiale}
Chaque donnée des fichiers CSV est chargée en mémoire, ce qui implique une complexité spatiale de $O(n)$, où $n$ est le nombre de lignes total dans tous les fichiers réunis. 

\section{Le Connexion Scan Algorithm}
\subsection{Choix de l'algorithme}
Dans le cadre de ce projet, nous avons choisi d'implémenter le \emph{Connection Scan Algorithm} (CSA) pour la recherche de chemin.
Cet algorithme est particulièrement adapté pour les réseaux de transport en commun, car il permet de trouver rapidement le meilleur chemin
entre deux arrêts en tenant compte des horaires de départ et d'arrivée. Le CSA a été conçu spécifiquement pour traiter les problèmes de planification d'itinéraires 
dans les systèmes de transport en commun. Cependant, il y avait d'autres algorithmes qui auraient pu être utilisés, tels que \emph{Dijkstra} ou \emph{A*}, 
alors pourquoi avoir fait ce choix.

\subsubsection{Fonctionnement}
\textbf{CSA}: Est basé sur une approche de recherche de chemin qui utilise une liste triée de connexions entre arrêts, et parcourt ces connexions de manière séquentielle.
Il parcourt les connexions dans l'ordre croissant du temps de départ, en mettant à jour les meilleurs temps d'arrivée à chaque arrêt. Il est
spécialisé pour les horaires de transports publics. 


\textbf{Dijkstra}: Cherche le plus court chemin en partant du noeud de départ et en explorant tous les voisins, en choisissant toujours le chemin avec 
le coût total le plus faible.
buildWalks
\textbf{A*}: Est une amélioration de Dijkstra qui utilise une heuristique pour guider la recherche vers la destination. Il est plus efficace que Dijkstra dans certains cas,
mais il nécessite une bonne heuristique pour fonctionner correctement.

\subsubsection{Facilité d'implémentation avec GTFS}
\textbf{CSA}: Est spécifiquement conçu pour fonctionner avec les fichiers GTFS et lit directement les connexions linéairement après le parsing et le tri des horaires.
triées par heure, il n'y a pas besoin de convertir les données en graphe.

\textbf{Dijkstra}: Nécessite de transformer les données de GTFS en graphe temporel (chaque arrêt devient un noeud).
Cette implémentation est moins naturelle que pour CSA mais marche tout aussi bien.

\textbf{A*}: Etant comme Dijkstra mais avec une heuristique, donc il faut lui ajouter l'heuristique. 
Il nécessite aussi une représentation temporelle du graphe.

\subsubsection{Complexité}
\textbf{CSA}: $O(n)$, où $n$ est le nombre de connexions. Très rapide en pratique pour les requêtes "earliest arrival" grâce au tri temporel. 
Cependant, il demande un tri préalablement, ce qui donne une complexité de $O(n \log n)$ pour le tri.

\textbf{Dijkstra}: $O((V + E) \log V)$, où $V$ est le nombre de noeuds et $E$ le nombre d'arêtes.

\textbf{A*}: $O((V + E) \log V)$, mais dépend de la qualité de l'heuristique. Il peut être plus rapide que Dijkstra si l'heuristique est bonne.

\subsubsection{Choix final}
De part la facilité d'implémentation avec les fichiers GTFS, la rapidité de l'algorithme et le fait qu'il soit conçu pour les horaires de transports publics,
nous avons choisi d'implémenter le \emph{Connection Scan Algorithm} (CSA) pour notre projet.

\subsection{Explication et description de l'algorithme}
Le Connection Scan Algorithm (CSA) est une méthode efficace pour résoudre les problèmes de planification d'itinéraires dans 
les réseaux de transports en commun basés sur des horaires, comme les trains et les bus. Contrairement aux algorithmes classiques 
qui utilisent une file de priorité (comme Dijkstra), le CSA se base sur une liste triée de tous les transports en commun, classés par 
leur heure de départ.

Il parcourt cette liste de manière séquentielle pour déterminer rapidement les meilleures connections possibles pour atteindre une 
destination dans un délai optimal ou avec le moins de changements de véhicule.

\subsection{Structures de l'algorithme et implémentation}
l'algorithme est stocké dans une classe \texttt{PathFinder} qui contient la méthode findPath qui implémente l'algorithme CSA.
\begin{table}[h]
  \centering
  \begin{tabular}{|l|l|p{8cm}|}
  \hline
  \textbf{Attribut/Méthode} & \textbf{Type/Retour} & \textbf{Description} \\
  \hline
  stopMap & Map$<$String, Stop$>$ & Map contenant les arrêts, indexés par leur identifiant. \\
  tripMap & Map$<$String, Trip$>$ & Map contenant les trajets, indexés par leur identifiant. \\
  routeMap & Map$<$String, Route$>$ & Map contenant les routes, indexées par leur identifiant. \\
  connexions & List$<$Connexion$>$ & Liste des connexions disponibles. \\
  \hline
  PathFinder & Constructeur & Initialise les maps des arrêts, trajets et routes. \\
  findPath & void & Implémente l'algorithme pour trouver le meilleur chemin dans le graphe. \\
  findStopsByName & List<Stop> & Recherche tous les arrêts du même nom dans la map des arrêts à partir du string donné en paramètre. \\
  \hline
  \end{tabular}
  \caption{Classe PathFinder}
\end{table}

\subsection{Pseudo-code}
\begin{algorithm}[H]
  \footnotesize
  \SetAlgoNlRelativeSize{-1}
  \DontPrintSemicolon
  \KwIn{start, destination, time}
  \KwOut{Affiche le chemin optimal ou un message d'erreur}
  \tcp{La liste de connexions est triée par heure de départ préalablement durant le parsing}
  
  Trouver \texttt{starting\_stops} et \texttt{end\_stops} dans \texttt{stopMap} \;
  \If{données invalides ou start = destination}{
      Afficher une erreur et \Return \;
  }
  
  Initialiser \texttt{shortestPath[stop]} à $\infty$ pour chaque stop \;
  \texttt{Mettre shortestPath[starting\_stop]} $\gets$ temps de départ \;
  
  \texttt{previousConnection} $\gets$ map vide \;
  
  \ForEach{connexion \texttt{c} dans \texttt{connexions}}{
      Récupérer \texttt{depart, arrive, depTime, arrTime} \;
      \If{\texttt{shortestPath[dep]} $\leq$ \texttt{depTime} \textbf{et} \texttt{shortestPath[arrive]} $>$ \texttt{arrTime}}{
          Mettre à jour \texttt{shortestPath[arrive]} et \texttt{previousConnection[arrive]} \;
      }
      \ForEach{walk depuis \texttt{depart}}{
          Calculer \texttt{walkTime} \;
          \If{\texttt{shortestPath[walkArr]} $>$ \texttt{walkTime}}{
              Mettre à jour \texttt{shortestPath[walkArr]} et \texttt{previousConnection[walkArr]} \;
          }
      }
  }

  \texttt{currentStop} $\gets$ \texttt{end\_stop} \;
  \While{\texttt{currentStop} dans \texttt{previousConnection}}{
      Ajouter la connexion à \texttt{path} au début \;
      \texttt{currentStop} $\gets$ origine de la connexion \;
  }
  
  \If{\texttt{currentStop} $\ne$ \texttt{starting\_stop}}{
      Afficher ``No path found'' et \Return \;
  }
  
  \If{\texttt{path} vide}{
      Afficher ``No path found'' \;
  }
  \Else{
      \ForEach{connexion dans \texttt{path}}{
          Afficher les infos de la connexion \;
      }
  }
  \caption{CSA -- Recherche de chemin entre deux arrêts sans marche à pied}
  \end{algorithm}
    
\subsection{Complexité sans la marche à pied}
Le début de l'algorithme se passe dans le parser, où nous lisons les fichiers CSV et construisons les connexions entre arrêts.
C'est alors, qu'en fin de parsing nous allons trier les connexions par heure de départ.
Ce tri a une complexité en $O(n \log n)$, où $n$ est le nombre de connexions. Nous utilisons Collections.sort(allConnexions) qui utilise un 
TimSort qui est un algorithme de tri se basant sur le tri par insertion et le tri fusion.

Vient ensuite la partie principale du CSA, où nous allons parcourir toutes les connexions une par une.
Ceci se fait en $O(n)$, où $n$ est le nombre de connexions. Etant donné que nous avons déjà trié les connexions, il suffit de les parcourir. 
De plus, étant donné que nous parcourons toutes les connexions, nous pouvons même dire que nous sommes en $\Theta(n)$.
Ainsi, la complexité totale de l'algorithme est dominée par le tri initial des connexions, ce qui donne une complexité globale de $O(n \log n)$, où $n$ 
est le nombre de connexions. Cette complexité est particulièrement avantageuse pour les grands ensembles de données, car elle permet un traitement efficace 
des requêtes après le prétraitement initial, cependant celle-ci demande un tri sur l'entièreté des connexions et est donc la partie la plus lourde du processus.

Tout ceci nous amène donc à une complexité totale de $O(n \log n)$ pour le parsing et la recherche de chemin, où $n$ est le nombre de connexions.

\section{Classes utilisées}

\section{Sources-bibliographie}
\cite{dibbelt2017connection} 
\cite{butts2020raptor}
\cite{epfl2024cs108}
\cite{transnetlabCSA}
\cite{gtfsReference}
\cite{futura2009distance}
\cite{geeko2018distance}
\cite{geeksforgeeks_haversine}
\cite{wikipedia_geohash}
\cite{mattaparthi2024ballkd}
\cite{fieldsend_onlineballtree}
\cite{woltmann2025astar}
\cite{wikipedia_astar}
\cite{geeksforgeeks_astar}
\cite{wikipedia_dijkstra}

\printbibliography


\end{document}