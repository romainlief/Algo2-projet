\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{indentfirst}
\usepackage{appendix}
\usepackage{libertine}
\usepackage{titlesec}
\usepackage{eso-pic}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{caption}
\usepackage{color}
\usepackage{setspace}
\usepackage[T1]{fontenc}
\usepackage[hyphens]{url}
\usepackage[backend=bibtex,style=alphabetic]{biblatex}
\addbibresource{source.bib}\usepackage[linkbordercolor=white]{hyperref}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{bm}
\usepackage{enumitem}
\usepackage{siunitx}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{commath}
\usepackage{cancel}
\usepackage{pdflscape}
\usepackage{svg}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e} % Retain only one package
\usepackage{comment}
\usepackage{placeins}

\usepackage{listings}
\lstset{literate=%
    {à}{{\`a}}1 {â}{{\^a}}1 {é}{{\'e}}1 {è}{{\`e}}1 {ê}{{\^e}}1 {ë}{{\"e}}1 {î}{{\^i}}1 {ï}{{\"i}}1 {ô}{{\^o}}1 {ö}{{\"o}}1 {ù}{{\`u}}1 {û}{{\^u}}1 {ü}{{\"u}}1 {ç}{{\c{c}}}1 {Ç}{{\c{C}}}1{―}{{\textemdash}}1
    {’}{{'}}1 {‘}{{`}}1 {“}{{``}}1 {”}{{''}}1
}
\urlstyle{same}
\pagestyle{fancy}
\fancyhead[L]{\leftmark}
\fancyhead[R]{}
\renewcommand{\subsectionmark}[1]{}


\usepackage{titlesec}
\usepackage{hyperref}

\titleclass{\subsubsubsection}{straight}[\subsection]


\newcounter{subsubsubsection}[subsubsection]
\renewcommand\thesubsubsubsection{\thesubsubsection.\arabic{subsubsubsection}}
\renewcommand\theparagraph{\thesubsubsubsection.\arabic{paragraph}} % optional; useful if paragraphs are to be numbered


\titleformat{\subsubsubsection}
  {\normalfont\normalsize\bfseries}{\thesubsubsubsection}{1em}{}
\titlespacing*{\subsubsubsection}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{5}{\z@}%
  {3.25ex \@plus1ex \@minus.2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\renewcommand\subparagraph{\@startsection{subparagraph}{6}{\parindent}%
  {3.25ex \@plus1ex \@minus .2ex}%
  {-1em}%
  {\normalfont\normalsize\bfseries}}
\def\toclevel@subsubsubsection{4}
\def\toclevel@paragraph{5}
\def\toclevel@paragraph{6}
\def\l@subsubsubsection{\@dottedtocline{4}{7em}{4em}}
\def\l@paragraph{\@dottedtocline{5}{10em}{5em}}
\def\l@subparagraph{\@dottedtocline{6}{14em}{6em}}
\makeatother
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\setlength{\headheight}{14.5pt}
\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{0.6}
\renewcommand{\headrulewidth}{1pt}
\newcommand{\HRule}{\rule{\linewidth}{0.3mm}}
\newcommand\BackgroundPic{%
	\put(0,0){%
		\parbox[b][\paperheight]{\paperwidth}{%
			\vfill
			\centering
			\includegraphics[width=\paperwidth,height=\paperheight,%
			keepaspectratio]{background.png}%
			\vfill}}}

% -----------------------------------------------------


\begin{document}
\AddToShipoutPicture*{\BackgroundPic}
\begin{titlepage}
  \begin{sffamily}
  \begin{flushleft} \large
    \includegraphics[height=2.0cm]{logo_ulb.jpg}
    \vspace{5cm}
   \end{flushleft}
  \begin{center}

    %Title
	\textsc{\huge INFO-F203 - Projets d'algorithmique 2}\\[1cm]

    \HRule \\[0.7cm]

	\textsc {\Huge Projet Mobilité}\\[0.4cm]

    \HRule \\[1.2cm]

% Author and supervisor
\begin{minipage}{0.5\textwidth}
\begin{flushleft} \large
\emph{Auteurs:}\\
Romain \textsc{Liefferinckx} - 000591790\\
Manuel \textsc{Rocca} - 000596086\\


\end{flushleft}
\end{minipage}


\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Professeurs:} \\
Jean  \textsc{Cardinal}\\
\emph{Assistants:} \\
Robin \textsc{Petit}
\end{flushright}
\end{minipage}


    \vfill

    %Bottom of the page
    {\large Année académique 2024-2025}
  \end{center}

  \end{sffamily}
\end{titlepage}


\clearpage


\tableofcontents

\newpage

% -----------------------------------------------------

\section{Introduction}
Dans le cadre de notre cours d'algorithmique INFO F-203, l'occasion s'est présentée à nous de créer un programme cherchant un chemin optimal
entre un point A et un point B sur base d'une heure de départ. En effet, sur base d'un ensemble de données
fournies sous format \emph{General Transit Feed Specification} (\textbf{GTFS}), nous avons utilisé le \emph{Connexion Scan Algorithm} (\textbf{CSA})
pour implémenter notre chercheur de chemin en \emph{Java}. 

Dans les sections à suivre, nous abordons le parsing des données, des structures formées à partir de celles-ci pour notre
implémentation et certains détails techniques comme la complexité temporelle et spatiale. Nous justifierons également certains choix
comme celui de l'algorithme précisé ci-dessus, à savoir le \textbf{CSA}.


\section{Parsing}
Dans cette section nous expliquons les procédés utilisés pour charger les données en mémoire à partir des fichiers CSV fournis ainsi que
les structures de données utilisées pour leur stockage et leur utilisation optimale dans l'algorithme choisi par nos soins.

Nous utilisons une classe Parser, qui se charge de la lecture des fichiers CSV.
Cette classe est responsable du remplissage de map avec les objets de type \emph{Connexion}, \emph{Route}, \emph{Stop}, \emph{StopTime} et \emph{Trip} en valeur venant des fichiers.
Qui nous permettent de créer les connexions entre arrêts, les routes et les trajets avec les données des fichiers csv.

\subsection{Structures de données pour le stockage}
Dû à notre choix d'implémentation algorithmique, nous avons opté pour des structures efficaces pour utiliser l'utiliser dans
les meilleurs conditions possibles. En effet, le CSA, comme son nom le suggère, fait une forte utilisation des connexions entre arrêts,
chose que nous détaillons plus loin dans ce rapport.

D'abord ont été créées les quatre classes principales, chacune correspondant à un type de fichier CSV donné. De manière générale, 
chaque champ de chaque fichier est repris comme un attribut de classe. Cela n'est cependant pas toujours le cas, nous le précisons
dans les sections adéquates.

\subsubsection{La classe Route}
Cette classe est une simple classe de stockage, chaque attribut correspondant à un champ des fichiers \emph{routes.csv}.

% Table qui détaille la classe Route
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    routeId & final String & L'id de la route représentée \\
    routeShortName & final String & Le nom de la route raccourci \\
    routeLongName & final String & Le nom de la route complet \\
    routeType & final String & Le type de véhicule utilisant cette route \\
    \hline
    \end{tabular}
    \caption{Classe Route}
\end{table}

\subsubsection{La classe StopTime}
La particularité de cette classe est qu'il lui manque le champ tripId donné dans les CSV concernés. Ce choix découle
de la structure de la classe Trip détaillée dans la section 2.1.4. % TODO: ajouter un label au tableau trip ici
\vspace{2cm}
% Table qui détaille la classe StopTime
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    departureTime & final String & L'heure du départ à partir de
                                   l'arrêt associé sur le trajet associé en format 
                                   heure;minutes;secondes \\
    stopId & final String & L'id de l'arrêt associé \\
    stopSequence & final int & Le numéro de l'arrêt dans le trajet associé \\
    \hline
    \end{tabular}
    \caption{Classe StopTime}
\end{table}

\subsubsection{La classe Stop}
Dans cette classe, hormis le fait que chaque champ des fichiers \emph{routes.csv} est repris, nous avons fait le choix d'ajouter
une liste de tripId, permettant de retrouver efficacement chaque Trip partant de cet arrêt. 

% Table qui détaille la classe Stop
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    stopId & final String & L'id du stop représenté \\
    stopName & final String & Le nom du stop \\
    stopLat & final String & La latitude du stop \\
    stopLon & final String & La longitude du stop \\
    trip\_ids & List$<$String$>$ & La liste des tous les trips (leurs ids) partant de ce stop \\
    \hline
    \end{tabular}
    \caption{Classe Stop}
\end{table}

\subsubsection{La classe Trip}
Une fois de plus, en plus des champs trouvés dans les fichiers \emph{trips.csv} retranscrits en attribut, nous avons ajouté
une liste de StopTime associés à ce Trip. Ceci nous permet de construire efficacement les connexions entre arrêts affublées
de temps de départ et d'arrivée.

% Table qui détaille la classe Trip
\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|p{8cm}|}
    \hline
    \textbf{Attribut} & \textbf{Type} & \textbf{Description} \\
    \hline
    tripId & final String & L'id du trip représenté \\
    routeId & final String & L'id de la route sur laquelle il passe \\
    stopTimes & List$<$StopTime$>$ &  La liste de tous les StopTime associés à ce trip \\
    \hline
    \end{tabular}
    \caption{Classe Trip}
\end{table}

\section{Le Connexion Scan Algorithm}
\subsection{Choix de l'algorithme}
Dans le cadre de ce projet, nous avons choisi d'implémenter le \emph{Connection Scan Algorithm} (CSA) pour la recherche de chemin.
Cet algorithme est particulièrement adapté pour les réseaux de transport en commun, car il permet de trouver rapidement le meilleur chemin
entre deux arrêts en tenant compte des horaires de départ et d'arrivée. Le CSA a été conçu spécifiquement pour traiter les problèmes de planification d'itinéraires 
dans les systèmes de transport en commun. Cependant, il y avait d'autres algorithmes qui auraient pu être utilisés, tels que \emph{Dijkstra} ou \emph{A*}, 
alors pourquoi avoir fait ce choix.

\subsubsection{Fonctionnement}
\textbf{CSA}: Est basé sur une approche de recherche de chemin qui utilise une liste triée de connexions entre arrêts, et parcourt ces connexions de manière séquentielle.
Il parcourt les connexions dans l’ordre croissant du temps de départ, en mettant à jour les meilleurs temps d’arrivée à chaque arrêt. Il est
spécialisé pour les horaires de transports publics. 


\textbf{Dijkstra}: Cherche le plus court chemin en partant du noeud de départ et en explorant tous les voisins, en choisissant toujours le chemin avec 
le coût total le plus faible.

\textbf{A*}: Est une amélioration de Dijkstra qui utilise une heuristique pour guider la recherche vers la destination. Il est plus efficace que Dijkstra dans certains cas,
mais il nécessite une bonne heuristique pour fonctionner correctement.

\subsubsection{Facilité d’implémentation avec GTFS}
\textbf{CSA}: Est spécifiquement conçu pour fonctionner avec les fichiers GTFS et lit directement les connexions linéairement après le parsing et le tri des horaires.
triées par heure, il n'y a pas besoin de convertir les données en graphe.

\textbf{Dijkstra}: Nécessite de transformer les données de GTFS en graphe temporel (chaque arrêt devient un noeud).
Cette implémentation est moins naturelle que pour CSA mais marche tout aussi bien.

\textbf{A*}: Etant comme Dijkstra mais avec une heuristique, donc il faut lui ajouter l'heuristique. 
Il nécessite aussi une représentation temporelle du graphe.

\subsubsection{Complexité}
\textbf{CSA}: $O(n)$, où $n$ est le nombre de connexions. Très rapide en pratique pour les requêtes "earliest arrival" grâce au tri temporel. 
Cependant, il demande un tri préalablement, ce qui donne une complexité de $O(n \log n)$ pour le tri.

\textbf{Dijkstra}: $O((V + E) \log V)$, où $V$ est le nombre de noeuds et $E$ le nombre d'arêtes.

\textbf{A*}: $O((V + E) \log V)$, mais dépend de la qualité de l'heuristique. Il peut être plus rapide que Dijkstra si l'heuristique est bonne.

\subsubsection{Choix final}
De part la facilité d'implémentation avec les fichiers GTFS, la rapidité de l'algorithme et le fait qu'il soit conçu pour les horaires de transports publics,
nous avons choisi d'implémenter le \emph{Connection Scan Algorithm} (CSA) pour notre projet.

\subsection{Explication et description de l'algorithme}
Le Connection Scan Algorithm (CSA) est une méthode efficace pour résoudre les problèmes de planification d'itinéraires dans 
les réseaux de transports en commun basés sur des horaires, comme les trains et les bus. Contrairement aux algorithmes classiques 
qui utilisent une file de priorité (comme Dijkstra), le CSA se base sur une liste triée de tous les transports en commun, classés par 
leur heure de départ.

Il parcourt cette liste de manière séquentielle pour déterminer rapidement les meilleures connections possibles pour atteindre une 
destination dans un délai optimal ou avec le moins de changements de véhicule.

\subsection{Structures de l'algorithme et implémentation}
l'algorithme est stocké dans une classe \texttt{PathFinder} qui contient la méthode findPath qui implémente l'algorithme CSA.
\begin{table}[h]
  \centering
  \begin{tabular}{|l|l|p{8cm}|}
  \hline
  \textbf{Attribut/Méthode} & \textbf{Type/Retour} & \textbf{Description} \\
  \hline
  stopMap & Map$<$String, Stop$>$ & Map contenant les arrêts, indexés par leur identifiant. \\
  tripMap & Map$<$String, Trip$>$ & Map contenant les trajets, indexés par leur identifiant. \\
  routeMap & Map$<$String, Route$>$ & Map contenant les routes, indexées par leur identifiant. \\
  connexions & List$<$Connexion$>$ & Liste des connexions disponibles. \\
  \hline
  PathFinder & Constructeur & Initialise les maps des arrêts, trajets et routes. \\
  findPath & void & Implémente l'algorithme pour trouver le meilleur chemin dans le graphe. \\
  findStopsByName & List<Stop> & Recherche tous les arrêts du même nom dans la map des arrêts à partir du string donné en paramètre. \\
  \hline
  \end{tabular}
  \caption{Classe PathFinder}
\end{table}

\subsection{Pseudo-code}
\begin{algorithm}[H]
  \footnotesize
  \SetAlgoNlRelativeSize{-1}
  \DontPrintSemicolon
  \KwIn{start, destination, time}
  \KwOut{Affiche le chemin optimal ou un message d'erreur}
  \tcp{La liste de connexions est triée par heure de départ préalablement durant le parsing}
  
  Trouver \texttt{starting\_stops} et \texttt{end\_stops} dans \texttt{stopMap} \;
  \If{données invalides ou start = destination}{
      Afficher une erreur et \Return \;
  }
  
  Initialiser \texttt{shortestPath[stop]} à $\infty$ pour chaque stop \;
  \texttt{Mettre shortestPath[starting\_stop]} $\gets$ temps de départ \;
  
  \texttt{previousConnection} $\gets$ map vide \;
  
  \ForEach{connexion \texttt{c} dans \texttt{connexions}}{
      Récupérer \texttt{depart, arrive, depTime, arrTime} \;
      \If{\texttt{shortestPath[dep]} $\leq$ \texttt{depTime} \textbf{et} \texttt{shortestPath[arrive]} $>$ \texttt{arrTime}}{
          Mettre à jour \texttt{shortestPath[arrive]} et \texttt{previousConnection[arrive]} \;
      }
      \ForEach{walk depuis \texttt{depart}}{
          Calculer \texttt{walkTime} \;
          \If{\texttt{shortestPath[walkArr]} $>$ \texttt{walkTime}}{
              Mettre à jour \texttt{shortestPath[walkArr]} et \texttt{previousConnection[walkArr]} \;
          }
      }
  }

  \texttt{currentStop} $\gets$ \texttt{end\_stop} \;
  \While{\texttt{currentStop} dans \texttt{previousConnection}}{
      Ajouter la connexion à \texttt{path} au début \;
      \texttt{currentStop} $\gets$ origine de la connexion \;
  }
  
  \If{\texttt{currentStop} $\ne$ \texttt{starting\_stop}}{
      Afficher ``No path found'' et \Return \;
  }
  
  \If{\texttt{path} vide}{
      Afficher ``No path found'' \;
  }
  \Else{
      \ForEach{connexion dans \texttt{path}}{
          Afficher les infos de la connexion \;
      }
  }
  \caption{CSA -- Recherche de chemin entre deux arrêts sans marche à pied}
  \end{algorithm}
    
\subsection{Complexité sans la marche à pied}
Le début de l'algorithme se passe dans le parser, où nous lisons les fichiers CSV et construisons les connexions entre arrêts.
C'est alors, qu'en fin de parsing nous allons trier les connexions par heure de départ.
Ce tri a une complexité en $O(n \log n)$, où $n$ est le nombre de connexions. Nous utilisons Collections.sort(allConnexions) qui utilise un 
TimSort qui est un algorithme de tri se basant sur le tri par insertion et le tri fusion.

Vient ensuite la partie principale du CSA, où nous allons parcourir toutes les connexions une par une.
Ceci se fait en $O(n)$, où $n$ est le nombre de connexions. Etant donné que nous avons déjà trié les connexions, il suffit de les parcourir. 
De plus, étant donné que nous parcourons toutes les connexions, nous pouvons même dire que nous sommes en $\Theta(n)$.
Ainsi, la complexité totale de l'algorithme est dominée par le tri initial des connexions, ce qui donne une complexité globale de $O(n \log n)$, où $n$ 
est le nombre de connexions. Cette complexité est particulièrement avantageuse pour les grands ensembles de données, car elle permet un traitement efficace 
des requêtes après le prétraitement initial, cependant celle-ci demande un tri sur l'entièreté des connexions et est donc la partie la plus lourde du processus.

Tout ceci nous amène donc à une complexité totale de $O(n \log n)$ pour le parsing et la recherche de chemin, où $n$ est le nombre de connexions.

\section{Classes utilisées}

\section{Sources-bibliographie}
\cite{dibbelt2017connection} 
\cite{butts2020raptor}
\cite{epfl2024cs108}
\cite{transnetlabCSA}
\cite{gtfsReference}
\cite{futura2009distance}
\cite{geeko2018distance}
\cite{geeksforgeeks_haversine}
\cite{wikipedia_geohash}
\cite{mattaparthi2024ballkd}
\cite{fieldsend_onlineballtree}
\cite{woltmann2025astar}
\cite{wikipedia_astar}
\cite{geeksforgeeks_astar}
\cite{wikipedia_dijkstra}

\printbibliography


\end{document}